"""Handles the list of files which are desired to be packed into the BSP."""
from enum import Enum
from zipfile import ZipFile
import os.path

from srctools.filesys import FileSystem, VPKFileSystem, FileSystemChain

from typing import Container

FILES = {}  # List of all the files we are packing.

# Files we know don't exist, they're generated by the engine or the like.
# We just want to skip out immediately when trying to pack them.
ENGINE_FILES = [
]

ENGINE_TEX = [
    # Water
    '_rt_reflection',
    '_rt_refraction',
    
    '_rt_camera',
    'env_cubemap', # Often in $envmap
    
    # Portal 1/2 - portal rendering
    '_rt_portal1',
    '_rt_portal2',
]

class FileType(Enum):
    """Types of files we might pack."""
    GENERIC = 0  # Other file types.
    SOUNDSCRIPT = 1  # Should be added to the manifest
    
    # Assume these files are present even
    # if we can't find them. (rt_ textures for example.)
    # also don't bother looking for dependencies.
    WHITELIST = 2
    
    # This file might be present - if it is pack it.
    # If not it's not an error.
    MAYBE = 3
    
    PARTICLE = 'pcf'  # Should be added to the manifest
    
    VSCRIPT_SQUIRREL = 'nut'
    
     # Implies packing referenced materials and textures.
    MATERIAL = 'vmt'
    
    TEXTURE = 'vtf'  # May want .hdr.vtf too.
    
    # Requires lookup of vtx, vvd, phy files too - in the model data.
    # also any skins used.
    MODEL = 'mdl'
    
EXT_TYPE = {
    '.' + filetype.value: filetype
    for filetype in FileType
    if isinstance(filetype.value, str)
}
    
class PackFile:
    """Represents a single file we are packing.
    
    data is raw data to pack directly, instead of from the filesystem.
    """
    __slots__ = ['type', 'filename', 'data', 'virtual']
    def __init__(
        self, 
        type: FileType,
        filename: str, 
        data: bytes=None,
    ):
        self.type = type
        self.filename = filename
        self.data = data
        self.virtual = data is not None

    def __repr__(self):
        text = '<{}{} Packfile "{}"'.format(
            'virtual ' if self.virtual else '',
            self.type.name,
            self.filename,
        )
        if self.data is not None:
            text += ' with {} bytes data>'.format(len(self.data))
        return text
            
    def get_data(self, filesys: FileSystem) -> bytes:
        """Read this file in. 
        
        If we have associated data, that is returned.
        Otherwise the filesystem is consulted for this file,
        and that is returned as well as cached.
        """
        if self.data is None:
            with filesys, filesys.open_bin(self.filename) as f:
                self.data = f.read()
        return self.data
        
def unify_path(path: str):
    """Convert paths to a unique form."""
    path = os.path.normpath(path).casefold().replace('\\', '/')
    if '../' in path:
        raise ValueError('Path tried to escape root!')
    return path.lstrip('/')

def pack_file(
    filename: str,
    data_type: FileType=FileType.GENERIC, 
    data: bytes=None,
):
    """Queue the given file to be packed. 
    If data is set, this file will use the given data.
    This returns the PackFile definition created.
    """
    path = unify_path(filename)
    try:
        file = FILES[path]
    except KeyError:
        pass
    else:
        # It's already here, is that OK?
        
        # Allow overriding data on disk with ours..
        if file.data is None: 
            if data is not None:
                file.data = data
                file.virtual = True
            # else: no data on either
        elif data == file.data:
            pass # Overrode with the same data, that's fine
        elif file.data:
            raise ValueError('"{}": two different data streams!'.format(filename))
        # else: we have an override, but asked to just pack.          
        
        if file.type is data_type:
            # Same, no problems - just packing on top.
            return file
            
        if file.type is FileType.GENERIC:
            file.type = data_type  # This is fine, we now know it has behaviour...
        elif data_type is FileType.GENERIC:
            return file # If we know it has behaviour, that trumps generic.
        
        if data_type is FileType.WHITELIST:
            file.type = data_type # Blindly believe this.
            
        raise ValueError('"{}": {} can\'t become a {}!'.format(
            filename, 
            file.type.name, 
            data_type.name,
        ))
        
    start, ext = os.path.splitext(path)
    
    # Try to promote generic to other types if known.
    if data_type is FileType.GENERIC:
        try:
            data_type = EXT_TYPE[ext]
        except KeyError:
            pass
    elif data_type is FileType.SOUNDSCRIPT:
        if ext != '.txt':
            raise ValueError('"{}" cannot be a soundscript!'.format(filename))
    
    FILES[path] = file = PackFile(
        data_type,
        filename,
        data,
    )
    return file      
        
def pack_into_zip(
    filesys: FileSystemChain, 
    zip_file: ZipFile, 
    block_filesys: Container[FileSystem]=(),
    ignore_vpk=True,
):
    """Pack all our files into the given zipfile.
    
    The filesys is used to find files to pack.
    If set, limit_filesys will disallow packing from the listed filesystems.
    If ignore_vpk is True, files in VPK won't be packed.
    """
    for pack_file in FILES.values():
        if file.virtual:
            # Always pack.
            zip_file.writestr(pack_file.filename, file.data)
            continue
        
        sys = filesys.get_system(pack_file.filename)

        if ignore_vpk and isinstance(sys, VPKFileSystem):
            continue
        elif sys in block_filesys:
            continue
        
        zip_file.writestr(pack_file.filename, file.get_data(sys))
    
def eval_dependencies(filesys: FileSystem):
    """Add files to the list which need to also be packed."
    
    For several files this has the side effect of reading in their data, 
    which will be saved.
    """
    # We might need to recurse to get depenencies of dependencies.
    # If this doesn't decrease each loop, we have a loop in files somewhere.
    todo = set(FILES.values())
    
    while todo:
        next_todo = set()
        
        # Check each, if dependencies found add them to next_todo and FILES
        for file in todo:
            if file.type is FileType.MATERIAL:
                next_todo.update(get_material_files(filesys, file))
            elif file.type is FileType.MODEL:
                next_todo.update(get_model_files(filesys, file))
            elif file.type is FileType.TEXTURE:
                # Try packing the '.hdr.vtf' file as well if present.
                next_todo.add(pack_file(file.filename[:-3] + 'hdr.vtf'))
        
        if next_todo == todo:
            # We looped twice with the same todo list.
            # we have a loop in refs here.
            raise ValueError(
                'Cannot find all packed files. '
                'Two or more depend on each other in the following list: \n'
                + '\n'.join('  {}\n'.format(file) for file in sorted(todo))
            )
        todo = next_todo
        
def get_model_files(filesys: FileSystem, file: PackFile):
    """Find any needed files for a model."""
        
def get_material_files(filesys: FileSystem, file: PackFile):
    """Find any needed files for a material."""
    pass

# Block packing these   
file = tex = None 
for file in ENGINE_FILES:
    pack_file(file, FileType.WHITELIST)
for tex in ENGINE_TEX:
    pack_file('materials/' + tex + '.vtf', FileType.WHITELIST)
del file, tex
